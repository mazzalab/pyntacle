

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pyntacle.algorithms.local_topology_NEW &mdash; pyntacle  documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="pyntacle  documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> pyntacle
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../pyntacle.html">pyntacle package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">pyntacle</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pyntacle.algorithms.local_topology_NEW</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pyntacle.algorithms.local_topology_NEW</h1><div class="highlight"><pre>
<span></span><span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Daniele Capocefalo, Mauro Truglio, Tommaso Mazza&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;Copyright 2018, The pyntacle Project&quot;</span>
<span class="n">__credits__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Ferenc Jordan&quot;</span><span class="p">]</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;0.0.1&quot;</span>
<span class="n">__maintainer__</span> <span class="o">=</span> <span class="s2">&quot;Daniele Capocefalo&quot;</span>
<span class="n">__email__</span> <span class="o">=</span> <span class="s2">&quot;d.capocefalo@css-mendel.it&quot;</span>
<span class="n">__status__</span> <span class="o">=</span> <span class="s2">&quot;Development&quot;</span>
<span class="n">__date__</span> <span class="o">=</span> <span class="s2">&quot;27 February 2018&quot;</span>
<span class="n">__license__</span> <span class="o">=</span> <span class="sa">u</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">  Copyright (C) 2016-2018  Tommaso Mazza &lt;t,mazza@css-mendel.it&gt;</span>
<span class="s2">  Viale Regina Margherita 261, 00198 Rome, Italy</span>

<span class="s2">  This program is free software; you can use and redistribute it under</span>
<span class="s2">  the terms of the BY-NC-ND license as published by</span>
<span class="s2">  Creative Commons; either version 4 of the License, or</span>
<span class="s2">  (at your option) any later version.</span>

<span class="s2">  This program is distributed in the hope that it will be useful,</span>
<span class="s2">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="s2">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="s2">  License for more details.</span>

<span class="s2">  You should have received a copy of the license along with this</span>
<span class="s2">  work. If not, see http://creativecommons.org/licenses/by-nc-nd/4.0/.</span>
<span class="s2">  &quot;&quot;&quot;</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">**Compute Local Topology metrics for all nodes in the graph or for a set of nodes**</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">misc.graph_routines</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">utils.graph_utils</span> <span class="k">import</span> <span class="n">GraphUtils</span> <span class="k">as</span> <span class="n">ut</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="k">import</span> <span class="n">jit</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="k">import</span> <span class="n">Enum</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<div class="viewcode-block" id="graph_type"><a class="viewcode-back" href="../../../pyntacle.algorithms.local_topology_NEW.html#pyntacle.algorithms.local_topology_NEW.graph_type">[docs]</a><span class="k">class</span> <span class="nc">graph_type</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An enumerator that contains the different modes that will be used to compute internally the shortest path of a graph</span>
<span class="sd">    For the record, I still prefer the string method</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">undirect_unweighted</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">undirect_weighted</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">direct_unweighted</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">direct_weighted</span> <span class="o">=</span> <span class="mi">3</span></div>


<div class="viewcode-block" id="implementation"><a class="viewcode-back" href="../../../pyntacle.algorithms.local_topology_NEW.html#pyntacle.algorithms.local_topology_NEW.implementation">[docs]</a><span class="k">class</span> <span class="nc">implementation</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    this enumerator stores the different ways that can be used to parallelize the shortest path</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">gpu</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">auto</span> <span class="o">=</span> <span class="mi">2</span></div>


<div class="viewcode-block" id="LocalTopology"><a class="viewcode-back" href="../../../pyntacle.algorithms.local_topology_NEW.html#pyntacle.algorithms.local_topology_NEW.LocalTopology">[docs]</a><span class="k">class</span> <span class="nc">LocalTopology</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    LocalTopology Computes information at a local level. Information is computed either for a single node or (if not</span>
<span class="sd">    specified) for the whole node set in a network</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LocalTopology.degree"><a class="viewcode-back" href="../../../pyntacle.algorithms.local_topology_NEW.html#pyntacle.algorithms.local_topology_NEW.LocalTopology.degree">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@check_graph_consistency</span>
    <span class="nd">@vertex_doctor</span>
    <span class="k">def</span> <span class="nf">degree</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the degree for a single node, a list of nodes or for all nodes in the Graph. The degree is defined as</span>
<span class="sd">        the number of incident edges to a single nodes.</span>
<span class="sd">        :param igraph.Graph graph: an igraph.Graph object. The graph should have specific properties. Please see the</span>
<span class="sd">        &quot;Minimum requirements&quot; specifications in pyntacle&#39;s manual</span>
<span class="sd">        :param nodes: if a node name, returns the degree of the input node. If a list of node names,</span>
<span class="sd">        the degree is returned for all node names.if None (default), the degree is computed for the whole graph.</span>
<span class="sd">        :return: a list of integers, the length being the number of input nodes. Each integer represent the degree</span>
<span class="sd">        of the input nodes</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">graph</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">graph</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">nodes</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">graph</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span></div>

<div class="viewcode-block" id="LocalTopology.betweenness"><a class="viewcode-back" href="../../../pyntacle.algorithms.local_topology_NEW.html#pyntacle.algorithms.local_topology_NEW.LocalTopology.betweenness">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@check_graph_consistency</span>
    <span class="nd">@vertex_doctor</span>
    <span class="k">def</span> <span class="nf">betweenness</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the betwenness for a single node, a list of nodes or for all nodes in the Graph.</span>
<span class="sd">        The degree is defined as the ratio of the number of shortest path that passes through the node</span>
<span class="sd">        over all shortest paths.</span>
<span class="sd">        :param igraph.Graph graph: an igraph.Graph object. The graph should have specific properties. Please see the</span>
<span class="sd">        &quot;Minimum requirements&quot; specifications in pyntacle&#39;s manual</span>
<span class="sd">        :param nodes: if a node name, returns the degree of the input node. If a list of node names,</span>
<span class="sd">        the degree is returned for all node names.if None (default), the degree is computed for the whole graph.</span>
<span class="sd">        :return: a list of floats, the length being the number of input nodes. Each float represent the betweenness</span>
<span class="sd">        of the input node</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">graph</span><span class="o">.</span><span class="n">betweenness</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">graph</span><span class="o">.</span><span class="n">betweenness</span><span class="p">(</span><span class="n">nodes</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">graph</span><span class="o">.</span><span class="n">betweenness</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span></div>

<div class="viewcode-block" id="LocalTopology.clustering_coefficient"><a class="viewcode-back" href="../../../pyntacle.algorithms.local_topology_NEW.html#pyntacle.algorithms.local_topology_NEW.LocalTopology.clustering_coefficient">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@check_graph_consistency</span>
    <span class="nd">@vertex_doctor</span>
    <span class="k">def</span> <span class="nf">clustering_coefficient</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the clustering coefficient for a single node, a list of nodes or for all nodes in the Graph.</span>
<span class="sd">        The clustering coefficient is defined as the number of triangles formed among the node&#39;s neighbours over the</span>
<span class="sd">        possible number of triangles that would be present if the input node(s) and its neighbours were a clique.</span>
<span class="sd">        If the degree of the input node(s) is less than two, the clustering coefficient of these nodes is set to zero.</span>
<span class="sd">        :param igraph.Graph graph: an igraph.Graph object. The graph should have specific properties. Please see the</span>
<span class="sd">        &quot;Minimum requirements&quot; specifications in pyntacle&#39;s manual</span>
<span class="sd">        :param nodes: if a node name, returns the degree of the input node. If a list of node names,</span>
<span class="sd">        the degree is returned for all node names.if None (default), the degree is computed for the whole graph.</span>
<span class="sd">        :return: a list of floats, the length being the number of input nodes. Each float represent the clustering</span>
<span class="sd">        coefficient of the input node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">graph</span><span class="o">.</span><span class="n">transitivity_local_undirected</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;zero&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">graph</span><span class="o">.</span><span class="n">transitivity_local_undirected</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;zero&quot;</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">graph</span><span class="o">.</span><span class="n">transitivity_local_undirected</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;zero&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="LocalTopology.closeness"><a class="viewcode-back" href="../../../pyntacle.algorithms.local_topology_NEW.html#pyntacle.algorithms.local_topology_NEW.LocalTopology.closeness">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@check_graph_consistency</span>
    <span class="nd">@vertex_doctor</span>
    <span class="k">def</span> <span class="nf">closeness</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the clustering coefficient for a single node, a list of nodes or for all nodes in the Graph.</span>
<span class="sd">        The closeness is defined as the sum of the length of the shortest paths passing through the node(s)</span>
<span class="sd">        over all the length of all shortest paths in the graph.</span>
<span class="sd">        :param igraph.Graph graph: an igraph.Graph object. The graph should have specific properties. Please see the</span>
<span class="sd">        &quot;Minimum requirements&quot; specifications in pyntacle&#39;s manual</span>
<span class="sd">        :param nodes: if a node name, returns the degree of the input node. If a list of node names,</span>
<span class="sd">        the degree is returned for all node names.if None (default), the degree is computed for the whole graph.</span>
<span class="sd">        :return: a list of floats, the length being the number of input nodes. Each float represent the closeness</span>
<span class="sd">        of the input node</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">graph</span><span class="o">.</span><span class="n">closeness</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">graph</span><span class="o">.</span><span class="n">closeness</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">nodes</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">graph</span><span class="o">.</span><span class="n">closeness</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">nodes</span><span class="p">)</span></div>

<div class="viewcode-block" id="LocalTopology.eccentricity"><a class="viewcode-back" href="../../../pyntacle.algorithms.local_topology_NEW.html#pyntacle.algorithms.local_topology_NEW.LocalTopology.eccentricity">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@check_graph_consistency</span>
    <span class="nd">@vertex_doctor</span>
    <span class="k">def</span> <span class="nf">eccentricity</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the eccentricity for a single node, a list of nodes or for all nodes in the Graph.</span>
<span class="sd">        The eccentricity is defined as the maximum of all the distances (shortest path) between the node(s)</span>
<span class="sd">        and all other nodes in the graph. The eccentricity of two disconnected nodes is defined as zero.</span>
<span class="sd">        :param igraph.Graph graph: an igraph.Graph object. The graph should have specific properties. Please see the</span>
<span class="sd">        &quot;Minimum requirements&quot; specifications in pyntacle&#39;s manual</span>
<span class="sd">        :param nodes: if a node name, returns the degree of the input node. If a list of node names,</span>
<span class="sd">        the degree is returned for all node names.if None (default), the degree is computed for the whole graph.</span>
<span class="sd">        :return: a list of integers, the length being the number of input nodes. Each float represent the closeness</span>
<span class="sd">        of the input node</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">eccentricity</span><span class="p">()]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">eccentricity</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">nodes</span><span class="p">))]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">eccentricity</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">nodes</span><span class="p">)]</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__radiality_inner</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="s2">&quot;igraph&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        inner class that handles the radiality calculus (without throwing any error)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">choices</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;igraph&quot;</span><span class="p">,</span> <span class="s2">&quot;parallel_CPU&quot;</span><span class="p">,</span> <span class="s2">&quot;parallel_GPU&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">implementation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">choices</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                <span class="s2">&quot;Implementation specified does not exists. Please choose among the following options </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">choices</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">diameter</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">diameter</span><span class="p">()</span>
            <span class="n">num_nodes</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">vcount</span><span class="p">()</span>
            <span class="n">rad</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list that will store radiality values</span>

            <span class="k">if</span> <span class="n">implementation</span> <span class="o">==</span> <span class="s2">&quot;igraph&quot;</span><span class="p">:</span>
                <span class="n">sps</span> <span class="o">=</span> <span class="n">LocalTopology</span><span class="o">.</span><span class="n">shortest_path_igraph</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">)</span>  <span class="c1"># recall the shortest path function here</span>

            <span class="k">elif</span> <span class="n">implementation</span> <span class="o">==</span> <span class="s2">&quot;parallel_CPU&quot;</span><span class="p">:</span>
                <span class="n">sps</span> <span class="o">=</span> <span class="n">LocalTopology</span><span class="o">.</span><span class="n">shortest_path_pyntacle</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span>
                                                           <span class="n">mode</span><span class="o">=</span><span class="n">graph_type</span><span class="o">.</span><span class="n">undirect_unweighted</span><span class="p">,</span>
                                                           <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="o">.</span><span class="n">cpu</span><span class="p">)</span>
                <span class="n">sps</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>  <span class="c1"># reconvert to a list of lists</span>
                <span class="n">sps</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">vcount</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">sps</span><span class="p">]</span>

            <span class="k">elif</span> <span class="n">implementation</span> <span class="o">==</span> <span class="s2">&quot;parallel_GPU&quot;</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Implementation </span><span class="si">{}</span><span class="s2"> not yet implemented</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">implementation</span><span class="p">))</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">sps</span><span class="p">:</span>  <span class="c1"># loop through the shortest path of each node name</span>
                <span class="n">partial_sum</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">sp_length</span> <span class="ow">in</span> <span class="n">sp</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">sp_length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">partial_sum</span> <span class="o">+=</span> <span class="n">diameter</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">sp_length</span>

                <span class="n">rad</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">partial_sum</span> <span class="o">/</span> <span class="p">(</span><span class="n">num_nodes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span> <span class="mi">5</span><span class="p">))</span>


            <span class="k">return</span> <span class="n">rad</span>

<div class="viewcode-block" id="LocalTopology.radiality"><a class="viewcode-back" href="../../../pyntacle.algorithms.local_topology_NEW.html#pyntacle.algorithms.local_topology_NEW.LocalTopology.radiality">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@check_graph_consistency</span>
    <span class="nd">@vertex_doctor</span>
    <span class="k">def</span> <span class="nf">radiality</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="s2">&quot;igraph&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the radiality for a single node, a list of nodes or for all nodes in the Graph. The radiality of a node</span>
<span class="sd">        (v) is calculated by computing the shortest path between the node v and all other nodes in the graph. The value</span>
<span class="sd">        of each path is then subtracted by the value of the diameter + 1 and the resulting values are summated and</span>
<span class="sd">        weighted over the total number of nodes -1. Finally, the obtained value is divided for the number of nodes -1</span>
<span class="sd">        (n-1).</span>
<span class="sd">        **WARNING:** Radiality works well when a graph is connected. If the node is disconnected, the radiality is</span>
<span class="sd">        always *-inf*. If the graph is  made of at least two components, we highly recommend using the *radiality_reach*</span>
<span class="sd">        method we implemented here</span>
<span class="sd">        :param igraph.Graph graph: an igraph.Graph object. The graph should have specific properties. Please see the</span>
<span class="sd">        &quot;Minimum requirements&quot; specifications in pyntacle&#39;s manual</span>
<span class="sd">        :param nodes: if a node name, returns the degree of the input node. If a list of node names,</span>
<span class="sd">        the degree is returned for all node names.if None (default), the degree is computed for the whole graph.</span>
<span class="sd">        :param str implementation: the way you prefer to compute the shortest path for the whole graph. choices are:</span>
<span class="sd">        * **`igraph`**: uses the Dijsktra&#39;s algorithm implemented from igraph</span>
<span class="sd">        * **`parallel_CPU`**: uses a parallel CPU implementation of the Floyd Warshall algorithm using numba</span>
<span class="sd">        * **`parallel_GPU`**: uses a parallel GPU implementation of the Floyd Warshall algorithm using numba</span>
<span class="sd">        **CAUTION:**(requires NVIDIA graphics compatible with CUDA)</span>
<span class="sd">        :return: a list of floats, the length being the number of input nodes. Each float represent the closeness</span>
<span class="sd">        of the input node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">LocalTopology</span><span class="o">.</span><span class="n">__radiality_inner</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="p">)</span></div>

<div class="viewcode-block" id="LocalTopology.radiality_reach"><a class="viewcode-back" href="../../../pyntacle.algorithms.local_topology_NEW.html#pyntacle.algorithms.local_topology_NEW.LocalTopology.radiality_reach">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@check_graph_consistency</span>
    <span class="nd">@vertex_doctor</span>
    <span class="k">def</span> <span class="nf">radiality_reach</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="s2">&quot;igraph&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the radiality reach for a single node, a list of nodes or for all nodes in the Graph.</span>
<span class="sd">        The radiality reach is a weighted measure of the canonical radiality and it is recommended for disconnected</span>
<span class="sd">        graphs. Specifically, if a graph has more than one components, we calculate the radiality for each node within</span>
<span class="sd">        its component, then we multiply the radiality value withe the proportion of te nodes of that component over all</span>
<span class="sd">        the nodes in the graph. The radiality reach of a graph with only one component will hence be equal to the</span>
<span class="sd">        radiality, while a graph with several components will have several radiality values.</span>
<span class="sd">        *if you want the radiality for a disconnected graph, we recommend to subset the original graph and then use</span>
<span class="sd">        the radiality() function containied in this module.*</span>
<span class="sd">        :param igraph.Graph graph: an igraph.Graph object. The graph should have specific properties. Please see the</span>
<span class="sd">        &quot;Minimum requirements&quot; specifications in pyntacle&#39;s manual</span>
<span class="sd">        :param nodes: if a node name, returns the degree of the input node. If a list of node names,</span>
<span class="sd">        the degree is returned for all node names.if None (default), the degree is computed for the whole graph.</span>
<span class="sd">        :param str implementation: the way you prefer to compute the shortest path for the whole graph. choices are:</span>
<span class="sd">        * *&#39;igraph&#39;*: uses the Dijsktra&#39;s algorithm implemented from igraph</span>
<span class="sd">        * *&#39;parallel_CPU&#39;*: uses a parallel CPU implementation of the Floyd-Warshall algorithm using numba</span>
<span class="sd">        * *&#39;parallel_GPU&#39;*: uses a parallel GPU implementation of the Floyd-Warshall algorithm using numba</span>
<span class="sd">        **(requires NVIDIA graphics compatible with CUDA)**</span>
<span class="sd">        :return: a list of floats, the length being the number of input nodes. Each float represent the closeness</span>
<span class="sd">        of the input node</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">comps</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">components</span><span class="p">()</span>  <span class="c1"># define each case</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">comps</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">LocalTopology</span><span class="o">.</span><span class="n">radiality</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">tot_nodes</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">vcount</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">tot_nodes</span>

                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">comps</span><span class="p">:</span>
                    <span class="n">subg</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">induced_subgraph</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">subg</span><span class="o">.</span><span class="n">ecount</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># isolates do not have a radiality_reach by definition</span>
                        <span class="n">rad</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">part_nodes</span> <span class="o">=</span> <span class="n">subg</span><span class="o">.</span><span class="n">vcount</span><span class="p">()</span>
                        <span class="n">rad</span> <span class="o">=</span> <span class="n">LocalTopology</span><span class="o">.</span><span class="n">__radiality_inner</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">subg</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span><span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="o">.</span><span class="n">auto</span><span class="p">)</span>

                        <span class="c1"># rebalance radiality by weighting it over the total number of nodes</span>
                        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rad</span><span class="p">):</span>
                            <span class="n">rad</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">elem</span> <span class="o">*</span> <span class="p">(</span><span class="n">part_nodes</span> <span class="o">/</span> <span class="n">tot_nodes</span><span class="p">)</span>

                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                        <span class="n">res</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">rad</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="k">return</span> <span class="n">res</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

                <span class="n">inds</span> <span class="o">=</span> <span class="n">ut</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">)</span><span class="o">.</span><span class="n">get_node_indices</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">comps</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">c</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inds</span><span class="p">):</span>
                        <span class="n">node_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">vs</span><span class="p">(</span><span class="n">c</span><span class="p">)[</span><span class="s2">&quot;name&quot;</span><span class="p">]))</span>
                        <span class="n">subg</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">induced_subgraph</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
                        <span class="n">part_nodes</span> <span class="o">=</span> <span class="n">subg</span><span class="o">.</span><span class="n">vcount</span><span class="p">()</span>
                        <span class="n">rad</span> <span class="o">=</span> <span class="n">LocalTopology</span><span class="o">.</span><span class="n">__radiality_inner</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">subg</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="n">node_names</span><span class="p">,</span>
                                                              <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rad</span><span class="p">):</span>
                            <span class="n">rad</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">elem</span> <span class="o">*</span> <span class="p">(</span><span class="n">part_nodes</span> <span class="o">/</span> <span class="n">tot_nodes</span><span class="p">)</span>

                        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node_names</span><span class="p">):</span>
                            <span class="n">orig_index</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                            <span class="n">res</span><span class="p">[</span><span class="n">orig_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">rad</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="LocalTopology.eigenvector_centrality"><a class="viewcode-back" href="../../../pyntacle.algorithms.local_topology_NEW.html#pyntacle.algorithms.local_topology_NEW.LocalTopology.eigenvector_centrality">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@check_graph_consistency</span>
    <span class="nd">@vertex_doctor</span>
    <span class="k">def</span> <span class="nf">eigenvector_centrality</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">scaled</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the eigenvector centrality for a single nodes, a group of selected nodes or all nodes in the graph.</span>
<span class="sd">        The eigenvector centrality is defined as the contribution of the leading eigenvector for a node among all the</span>
<span class="sd">        other nodes in its graph. It represents the importance of a node with respect to its neighbours.</span>
<span class="sd">        :param igraph.Graph graph: an igraph.Graph object. The graph should have specific properties. Please see the</span>
<span class="sd">        &quot;Minimum requirements&quot; specifications in pyntacle&#39;s manual</span>
<span class="sd">        :param nodes: if a node name, returns the degree of the input node. If a list of node names,</span>
<span class="sd">        the shortest path between the input nodes and all other nodes in the graph is returned for all node names.</span>
<span class="sd">        If None (default), the degree is computed for the whole graph.</span>
<span class="sd">        :param bool scaled: a Boolean to scale the eigenvector centrality using the reciprocal of the eigenvector</span>
<span class="sd">        (1/eigenvector). Default is False.</span>
<span class="sd">        :return: a list of floats, the length being the number of input nodes. Each value is the eigenvector centrality</span>
<span class="sd">        value for the selected node(s)..</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scaled</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Scaled must be a boolean&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">graph</span><span class="o">.</span><span class="n">evcent</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scaled</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">ut</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">)</span><span class="o">.</span><span class="n">get_node_indices</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
            <span class="n">evcent_values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">evcent</span><span class="p">(</span><span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scaled</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inds</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">evcent_values</span></div>

<div class="viewcode-block" id="LocalTopology.pagerank"><a class="viewcode-back" href="../../../pyntacle.algorithms.local_topology_NEW.html#pyntacle.algorithms.local_topology_NEW.LocalTopology.pagerank">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@check_graph_consistency</span>
    <span class="nd">@vertex_doctor</span>
    <span class="k">def</span> <span class="nf">pagerank</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">0.85</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the Google PageRank algorithm from the input node(s), or for all nodes in the graph if it&#39;s not</span>
<span class="sd">        specified. The PageRank algorithm is a modifed version of the eigenvector centrality. It highlights the</span>
<span class="sd">        importance of a node by means of the number of edges that connects him and if these edges come from neighbours</span>
<span class="sd">        with high centrality. A likelihood distribution is computed to check what is the chance that a random walk</span>
<span class="sd">        passes through the selected node(s). the higher is the centrality of the node, the higher is the probability of</span>
<span class="sd">        passing through it. for more info, please refer to http://infolab.stanford.edu/~backrub/google.html for more</span>
<span class="sd">        info.</span>
<span class="sd">        :param graph: an igraph.Graph object. The graph should have specific properties. Please see the</span>
<span class="sd">        &quot;Minimum requirements&quot; specifications in pyntacle&#39;s manual</span>
<span class="sd">        :param nodes: if a node name, returns the degree of the input node. If a list of node names,</span>
<span class="sd">        the shortest path between the input nodes and all other nodes in the graph is returned for all node names.</span>
<span class="sd">        If None (default), the degree is computed for the whole graph.</span>
<span class="sd">        :param weights: a list of floats minus or equal to the total number of edges.</span>
<span class="sd">        :param damping : a damping factor representing the probability to reset the random walk distribution at each</span>
<span class="sd">        pagerank iteration. Default is 0.85.</span>
<span class="sd">        :return: a list of floats representing the pagerank value for the selected node(s)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Weights must be a list of floats&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">weights</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Weights must be a list of floats&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">damping</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">damping</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Damping factor must be a float &gt;= 0&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">graph</span><span class="o">.</span><span class="n">ecount</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Weights must be equal or inferior to the total number of edges&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">graph</span><span class="o">.</span><span class="n">pagerank</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span></div>

<div class="viewcode-block" id="LocalTopology.shortest_path_igraph"><a class="viewcode-back" href="../../../pyntacle.algorithms.local_topology_NEW.html#pyntacle.algorithms.local_topology_NEW.LocalTopology.shortest_path_igraph">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@check_graph_consistency</span>
    <span class="nd">@vertex_doctor</span>
    <span class="k">def</span> <span class="nf">shortest_path_igraph</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the shortest path for a single node, a list of nodes or for all nodes in the Graph using the Dijkstra&#39;s</span>
<span class="sd">        implementation of the igraph Package (works on a single CPU core). The shortest path is the minimum distance</span>
<span class="sd">        from the input node to every other node in the graph. The distance between two disconnected nodes is represented</span>
<span class="sd">        as *&#39;inf&#39;* (a *math.inf* object).</span>
<span class="sd">        :param graph: an igraph.Graph object. The graph should have specific properties. Please see the</span>
<span class="sd">        &quot;Minimum requirements&quot; specifications in pyntacle&#39;s manual</span>
<span class="sd">        :param nodes: if a node name, returns the degree of the input node. If a list of node names,</span>
<span class="sd">        the shortest path between the input nodes and all other nodes in the graph is returned for all node names.</span>
<span class="sd">        If None (default), the degree is computed for the whole graph.</span>
<span class="sd">        :param numpy: a **Boolean** that allows to output a list of lists or a &#39;numpy array object</span>
<span class="sd">        &lt;https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.array.html&gt;&#39;_. Default is **False**,</span>
<span class="sd">        while it&#39;s **True** for the other shortest path implementations.</span>
<span class="sd">        :return: a list of lists, the length being the number of input nodes. Each list contains a series of integers</span>
<span class="sd">        representing the distance from the input node(s) to every other node in the graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sp</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">shortest_paths</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">sp</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">shortest_paths</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">nodes</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sp</span></div>

<div class="viewcode-block" id="LocalTopology.shortest_path_pyntacle"><a class="viewcode-back" href="../../../pyntacle.algorithms.local_topology_NEW.html#pyntacle.algorithms.local_topology_NEW.LocalTopology.shortest_path_pyntacle">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@check_graph_consistency</span>
    <span class="nd">@vertex_doctor</span>
    <span class="k">def</span> <span class="nf">shortest_path_pyntacle</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">graph_type</span><span class="o">.</span><span class="n">undirect_unweighted</span><span class="p">,</span>
                               <span class="n">implementation</span><span class="o">=</span><span class="n">implementation</span><span class="o">.</span><span class="n">cpu</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        We implement here a phew ways to determine the shortest paths in a graph for a single node, a group of nodes or</span>
<span class="sd">        all nodes in a graph. The shortest path search is performed using the Floyd-Warhsall algorithm and the numba</span>
<span class="sd">        library for HPC computing in order to parallelize the search as quickly as possible. Currently we support the</span>
<span class="sd">        use</span>
<span class="sd">        :param igraph.Graph graph: an igraph.Graph object. The graph should have specific properties. Please see the</span>
<span class="sd">        &quot;Minimum requirements&quot; specifications in pyntacle&#39;s manual</span>
<span class="sd">        :param nodes: if a node name, returns the degree of the input node. If a list of node names,</span>
<span class="sd">        the shortest path between the input nodes and all other nodes in the graph is returned for all node names.</span>
<span class="sd">        If None (default), the degree is computed for the whole graph.</span>
<span class="sd">        :param graph_type mode: an enumerator containing the type of node to be implemented. Choices are:</span>
<span class="sd">        * **`graph_type.undirect_unweighted`**: perform shortest path search for an unweighted and undirect graph</span>
<span class="sd">        (default).</span>
<span class="sd">        * **`graph_type.undirect_weighted`**: shortest path for a weighted undirect network. In this case, the reserved</span>
<span class="sd">        attribute &quot;__weight&quot; at the edge level must be present and filled. **TO BE IMPLEMENTED**</span>
<span class="sd">        * **`graph_type_direct_unweighted`**: unweighted direct graph **TO BE IMPLEMENTED**</span>
<span class="sd">        * **`graph type_direct_weighted`**: weighted directed graph. In this case, the reserved attribute &quot;__weight&quot;</span>
<span class="sd">        at the edge level must be present and filled. **TO BE IMPLEMENTED**</span>
<span class="sd">        :param implementation :an enumerator containing the type of parallelization that will be used. Choices are:</span>
<span class="sd">        * **`implementation.cpu`**: parallelize the SP search using the maximum number of threads available on the CPU</span>
<span class="sd">        * **`implementation.gpu`**: parallelize the SP search using a GPU implementation and nVidia Graphics.</span>
<span class="sd">        **TO BE IMPLEMENTED**</span>
<span class="sd">        **CAUTION**: this will not work if the GPU is not present or CUDA compatible.</span>
<span class="sd">        * **`implementation.auto`**: performs the shortest path using criteria defined by us, according to the machine specifications</span>
<span class="sd">        and the graph topology.</span>
<span class="sd">        :return: a numpy array storing the shortest path matrix for a single node, a list of nodes or all nodes in the</span>
<span class="sd">        graph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#todo automatic implementation</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">graph_type</span><span class="o">.</span><span class="n">undirect_unweighted</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

                <span class="n">adjmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">get_adjacency</span><span class="p">()),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">adjmat</span><span class="p">[</span><span class="n">adjmat</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">vcount</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># set zero values to the max possible path length + 1</span>
                <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">adjmat</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># set diagonal values to 0 (no distance from itself)</span>

                <span class="k">if</span> <span class="n">implementation</span> <span class="o">==</span> <span class="n">implementation</span><span class="o">.</span><span class="n">cpu</span> <span class="ow">or</span> <span class="n">implementation</span> <span class="o">==</span> <span class="n">implementation</span><span class="o">.</span><span class="n">auto</span><span class="p">:</span>
                    <span class="n">sps</span> <span class="o">=</span> <span class="n">LocalTopology</span><span class="o">.</span><span class="n">__shortest_path_CPU</span><span class="p">(</span><span class="n">adjmat</span><span class="o">=</span><span class="n">adjmat</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">sps</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                        <span class="s2">&quot;Implementation </span><span class="si">{}</span><span class="s2"> not available at the time using CPU, please come back soon &quot;</span>
                        <span class="s2">&quot;for the modifed version&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">implementation</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                    <span class="n">sps</span> <span class="o">=</span> <span class="n">LocalTopology</span><span class="o">.</span><span class="n">__shortest_path_CPU</span><span class="p">(</span><span class="n">adjmat</span><span class="o">=</span><span class="n">adjmat</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">sps</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Not yet available for a subset of nodes in the graph&quot;</span><span class="p">)</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Shortest path for </span><span class="si">{}</span><span class="s2"> not yet implemented, come back soon!</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__shortest_path_CPU</span><span class="p">(</span><span class="n">adjmat</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the shortest paths of a graph for aa single nodes, a set of nodes or all nodes in the graph using</span>
<span class="sd">        &#39;Floyd-Warshall Implementation &lt;https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm&gt;&#39;_. The forumla</span>
<span class="sd">        is implemented using the numba library and allows for parallelization using CPU cores.</span>
<span class="sd">        :param np.ndarray adjmat: a numpy.ndarray containing the adjacency matrix of a graph. Disconnected nodes in the</span>
<span class="sd">        matrix are represented as the total number of nodes in the graph + 1, while the diagonal must contain zeroes.</span>
<span class="sd">        Default is True (a numpy array is returned)</span>
<span class="sd">        :return: a numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">v</span> <span class="o">=</span> <span class="n">adjmat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">adjmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">adjmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">adjmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">adjmat</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]:</span>
                        <span class="n">adjmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">adjmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">adjmat</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">adjmat</span></div>

    <span class="c1"># #todo rewrite to work only on upper or lower triangular matrix</span>
    <span class="c1"># @staticmethod</span>
    <span class="c1"># @cuda.jit(argtypes=[u2[:, :], u2[:, :]])</span>
    <span class="c1"># @check_graph_consistency</span>
    <span class="c1"># @vertex_doctor</span>
    <span class="c1"># def shortest_path_gpu(graph, nodes=None, numpy=True):</span>
    <span class="c1">#     # tx = cuda.threadIdx.x  # Thread ids in a 2D block</span>
    <span class="c1">#     # ty = cuda.threadIdx.y</span>
    <span class="c1">#     #</span>
    <span class="c1">#     # bx = cuda.blockIdx.x   # Block ids in a 2D grid</span>
    <span class="c1">#     # by = cuda.blockIdx.y</span>
    <span class="c1">#     #</span>
    <span class="c1">#     # bdx = cuda.blockDim.x  # Block width, i.e. number of threads per block</span>
    <span class="c1">#     # bdy = cuda.blockDim.y</span>
    <span class="c1">#     #</span>
    <span class="c1">#     # posx = tx + bx * bdx</span>
    <span class="c1">#     # posy = ty + by * bdy</span>
    <span class="c1">#</span>
    <span class="c1">#     posx, posy = cuda.grid(2)</span>
    <span class="c1">#     graph_size = graph.shape[0]</span>
    <span class="c1">#     if posx &lt; graph_size and posy &lt; graph_size:  # Check array boundaries</span>
    <span class="c1">#         min_path = graph[posx, posy]</span>
    <span class="c1">#</span>
    <span class="c1">#         posXY = min_path</span>
    <span class="c1">#         if posXY &gt; 2:</span>
    <span class="c1">#             for k in range(0, graph_size):</span>
    <span class="c1">#                 posXK = graph[posx, k]</span>
    <span class="c1">#                 posKY = graph[k, posy]</span>
    <span class="c1">#</span>
    <span class="c1">#                 if posXY &gt; posXK + posKY:</span>
    <span class="c1">#                     min_path = posXK + posKY</span>
    <span class="c1">#</span>
    <span class="c1">#                 if min_path == 2:</span>
    <span class="c1">#                     break</span>
    <span class="c1">#</span>
    <span class="c1">#         result[posx, posy] = min_path</span>

<span class="c1"># todo missing stuff:</span>
<span class="c1"># todo shortest path cpu: single nodes or group of nodes</span>
<span class="c1"># todo shortest path gpu: both</span>
<span class="c1"># todo all the other graphs</span>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Author.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>